syntax = "proto3";

package bcpb;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

// enum BlockState {
//     INIT      = 0;
//     // Waiting for signers
//     SIGN      = 1;
//     // Signing complete
//     SIGNED    = 2;
//     // Block has been generated, submitted & broadcasted
//     GEN = 3;
//     // Waiting for enough commits
//     COMMIT    = 4;
//     // Quorum blocks committed. Exec takes place after this
//     COMMITED  = 5;
// }

// enum Consistency {
//     // Return immediately
//     NONE = 0;
//     // Return immediately.  This is a temp placeholder
//     WEAK = 1;
//     // Return after ratification. This maps to BlockState_COMMITTED
//     RATIFIED = 2;
//     // Return after execution is complete
//     EXECD = 3;
// }

message BlockHeader {
    // Block height in the chain. Genesis will always be 0
    uint32 Height = 1;
    // Previous block digest.  This is zero for the genesis block
    bytes PrevBlock = 2 [(gogoproto.casttype) = "Digest"];
    // Timestamp when block creation was started
    int64 Timestamp = 3;
    // Incrementing nonce
    uint64 Nonce = 4;
    // Root hash of all tx's
    bytes Root = 5 [(gogoproto.casttype) = "Digest"];
    // All block signers
    repeated bytes Signers = 6 [(gogoproto.casttype) = "PublicKey"];
    // Node that proposed the block
    int32 ProposerIndex = 7;
    // Total number of signers for this block
    int32 N = 8;
    // Number of signatures.  This must be a atleast quorum value of N
    int32 S = 9;
    // Number of commits.  This must be a atleast quorum value of N
    int32 Q = 10;
}

// Block is a ledger block
message Block {
    // Block header.  All signature data should be part of the ledger
    BlockHeader Header = 1;

    // List of tx ids part of this block
    repeated bytes Txs = 2 [(gogoproto.casttype) = "Digest"];

    // Signatures associated to each pubkey
    repeated bytes Signatures = 3;
}

message TxHeader {
    // Tx timestamp
    int64 Timestamp = 1;

    // Payload hash
    bytes Data = 2 [(gogoproto.casttype) = "Digest"];

    // Payload size
    int64 DataSize = 3;
}

// TxnInput contains all data needed to use the referenced output
message TxInput {
    // Previous txn. Empty if no previous output needed as input
    bytes Ref = 1 [(gogoproto.casttype) = "Digest"];

    // Output index in txn. -1 if no previous output needed as input
    int32 Index = 2;

    // Public key as set in the output tx being referenced and used to verify
    // the signature below TODO: accept multiple for multi-sig
    repeated bytes PubKeys = 3 [(gogoproto.casttype) = "PublicKey"];


    // Data needed to unlock TxnOutput OR i.e.
    // signature along with any other data.  This is used in conjunction with
    // the TxnOutput referenced by the above fields to unlock the referenced
    // TxnOutput. All data after the pub keys length is consider part of the
    // state transition and unlock logic
    repeated bytes Signatures = 4;
}

message TxOutput {
    // Key used to identify the data
    bytes DataKey = 1 [(gogoproto.casttype) = "DataKey"];

    // Actual data associated to the key
    bytes Data = 2;

    // This is the quantity / available units of 'data'
    int64 Counter = 3;

    // Recipients (plural) public key. These are check along with the logic
    repeated bytes PubKeys = 4 [(gogoproto.casttype) = "PublicKey"];

    // Defines the 'verification' logic using TxnInput.Signature as data.  This
    // is run as a check along with the public key match
    bytes Logic = 5;
}


message Tx {
    // Tx header including the transaction type
    TxHeader Header = 1;

    repeated TxInput Inputs = 2;

    repeated TxOutput Outputs = 3;

    bytes Digest = 4 [(gogoproto.casttype) = "Digest"];
}

// All fields except type are optional and used based on context
// message Message {
//     enum Type {
//         BOOTSTRAP = 0; // Bootstrap root ledger
//         PROPOSAL = 2;  // New block proposal
//         SIGNATURE = 3; // Request announcing block signed
//         GENERATED = 4; // Request announcing block generation
//         REPLAY = 5;    // Block replay to get the log to the current state
//     }
//
//     // Type of message
//     Type type = 1;
//
//     // Block in question
//     Block block = 2;
//
//     // Entity who sent the message where applicable
//     bytes from = 3 [(gogoproto.casttype) = "PublicKey"];
//
//     // Tx's part of the block that are in question
//     repeated Tx txs = 4;
//
//     Consistency consistency = 5;
// }
